public class PartyDetailsController {

    // Search accounts by name
    @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + String.escapeSingleQuotes(searchKey) + '%';
        return [
            SELECT Id, Name
            FROM Account
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    // Get account details by Id
    @AuraEnabled(cacheable=true)
    public static AccountDetails getAccountDetails(Id accountId) {
        if (accountId == null) {
            return new AccountDetails();
        }

        Account acc;
        try {
            acc = [
                SELECT Id, Name, nSBA__DBA__c, Industry, Legal_Entity__c, Role__c,
                       NumberOfEmployees, AnnualRevenue, Net_Profit__c, Comments__c
                FROM Account
                WHERE Id = :accountId
                LIMIT 1
            ];
        } catch (Exception e) {
            throw new AuraHandledException('Apex error in getAccountDetails: ' + e.getMessage());
        }

        AccountDetails details = new AccountDetails();
        details.id             = acc.Id;
        details.companyName    = acc.Name;
        details.dba            = acc.nSBA__DBA__c;
        details.industry       = acc.Industry;
        details.employees      = acc.NumberOfEmployees;
        details.annualRevenue  = acc.AnnualRevenue != null ? String.valueOf(acc.AnnualRevenue) : null;
        details.netProfit      = acc.Net_Profit__c != null ? String.valueOf(acc.Net_Profit__c) : null;
        details.legalEntity    = acc.Legal_Entity__c;
        details.comment        = acc.Comments__c;
        return details;
    }

   @AuraEnabled(cacheable=true)
public static AccountDetails getAccountDetailsFromAppForm(Id appFormId) {
    if(appFormId == null) return new AccountDetails();

    ApplicationForm app = [
        SELECT Id, AccountId 
        FROM ApplicationForm
        WHERE Id = :appFormId
        LIMIT 1
    ];

    if(app.AccountId == null){
        return new AccountDetails(); // no related account
    }

    return getAccountDetails(app.AccountId);
}


    // Update Account fields
    @AuraEnabled
    public static void updateAccount(Id accountId, AccountDetails accDetails) {
        try {
            Account acc = new Account(Id = accountId);

            acc.Name             = accDetails.companyName;
            acc.nSBA__DBA__c     = accDetails.dba;
            acc.Industry         = accDetails.industry;
            acc.NumberOfEmployees= accDetails.employees;

            if (!String.isBlank(accDetails.annualRevenue)) {
                acc.AnnualRevenue = Decimal.valueOf(accDetails.annualRevenue);
            }
            if (!String.isBlank(accDetails.netProfit)) {
                acc.Net_Profit__c = Decimal.valueOf(accDetails.netProfit);
            }

            acc.Legal_Entity__c = accDetails.legalEntity;
            acc.Comments__c     = accDetails.comment;

            update acc;
        } catch (Exception e) {
            throw new AuraHandledException('Update failed: ' + e.getMessage());
        }
    }

    // Apex wrapper for account data
    public class AccountDetails {
        @AuraEnabled public Id id;
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
        @AuraEnabled public String comment;
    }


import { LightningElement, track, api } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import getAccountDetailsFromAppForm from '@salesforce/apex/PartyDetailsController.getAccountDetailsFromAppForm';
import updateAccount from '@salesforce/apex/PartyDetailsController.updateAccount';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
    @api recordId; 
    @track applicants = [];
    @api additionalApplicants = [];
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};
    @track selectedAccountId;

    // Create empty applicant template
    createEmptyApplicant() {
        return {
            key: Date.now(),
            Id: '',
            selectedPartyProfile: '',
            firstName: '',
            middleName: '',
            lastName: '',
            email: '',
            phoneNumber: '',
            ssn: '',
            dob: '',
            Suffix: '',
            citizenship: ''
        };
    }

    connectedCallback() {
        if (this.recordId) {
            this.prefillAccountFromAppForm(this.recordId);
        }

        if (!this.additionalApplicants || this.additionalApplicants.length === 0) {
            this.addApplicant();
        } else {
            this.processAdditionalApplicant(this.additionalApplicants);
        }
    }

    async prefillAccountFromAppForm(appFormId) {
        try {
            const accountDetails = await getAccountDetailsFromAppForm({ appFormId });
            this.formData = { ...accountDetails };
            this.selectedAccountId = accountDetails.id;
        } catch (error) {
            console.error('Error fetching related account:', error);
        }
    }

    processAdditionalApplicant(applicants) {
        if (!Array.isArray(applicants)) {
            applicants = [applicants];
        }
        this.applicants = applicants.map(applicant => ({ key: Date.now(), ...applicant }));
    }

    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            this.searchResults = await searchAccounts({ searchKey: this.searchKey });
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        this.selectedAccountId = event.currentTarget.dataset.id;
        this.searchResults = [];
        try {
            const details = await getAccountDetails({ accountId: this.selectedAccountId });
            this.formData = { ...details };
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }

    handleInputChange(event) {
        const index = event.target.dataset.index;
        const field = event.target.dataset.field;
        if(index !== undefined) {
            this.applicants[index][field] = event.target.value;
            this.updateToOmniScript();
        } else {
            this.formData[field] = event.target.value;
        }
    }

    async handleUpdate() {
        try {
            await updateAccount({ accountId: this.formData.id, accDetails: this.formData });
            this.dispatchEvent(new ShowToastEvent({
                title: 'Success',
                message: 'Account updated successfully',
                variant: 'success'
            }));
        } catch (error) {
            console.error('Error updating account:', error);
            this.dispatchEvent(new ShowToastEvent({
                title: 'Error Updating Account',
                message: error.body ? error.body.message : 'Unknown error',
                variant: 'error'
            }));
        }
    }

    addApplicant() {
        this.applicants = [...this.applicants, this.createEmptyApplicant()];
        this.updateToOmniScript();
    }

    removeApplicant(event) {
        const index = event.target.dataset.index;
        if (this.applicants.length > 1) {
            this.applicants.splice(index, 1);
            this.applicants = [...this.applicants];
        }
        this.updateToOmniScript();
    }

    updateToOmniScript() {
        let data = { AdditionalApplicants: this.applicants };
        this.omniApplyCallResp(data);
    }
}

<template>
    <template for:each={applicants} for:item="applicant" for:index="index">
        <div key={applicant.key} class="slds-box slds-m-around_medium">
            <lightning-card title="Borrowers / Guarantors">

                <!-- Account Search Input -->
                <template if:false={selectedAccountId}>
                    <div class="slds-m-around_medium">
                        <lightning-input 
                            label="Select Existing Business Relationship Record"
                            type="text"
                            value={searchKey}
                            onchange={handleSearchKeyChange}
                            placeholder="Type account name..."
                            class="slds-size_1-of-1">
                        </lightning-input>

                        <template if:true={searchResults.length}>
                            <div class="slds-box slds-m-top_x-small">
                                <template for:each={searchResults} for:item="acc">
                                    <div key={acc.Id} class="slds-p-around_x-small slds-border_bottom" 
                                        onclick={handleAccountSelect} data-id={acc.Id}>
                                        {acc.Name}
                                    </div>
                                </template>
                            </div>
                        </template>
                    </div>
                </template>

                <!-- Account Form Fields -->
                <div class="slds-grid slds-wrap slds-m-around_medium">
                    <lightning-input class="slds-size_1-of-2" label="Company Name" value={formData.companyName} data-field="companyName" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="DBA" value={formData.dba} data-field="dba" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="Industry" value={formData.industry} data-field="industry" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="Employees" type="number" value={formData.employees} data-field="employees" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="Annual Revenue" value={formData.annualRevenue} data-field="annualRevenue" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="Net Profit" value={formData.netProfit} data-field="netProfit" onchange={handleInputChange}></lightning-input>
                    <lightning-input class="slds-size_1-of-2" label="Legal Entity" value={formData.legalEntity} data-field="legalEntity" onchange={handleInputChange}></lightning-input>
                    <lightning-textarea class="slds-size_1-of-1" label="Comment" value={formData.comment} data-field="comment" onchange={handleInputChange}></lightning-textarea>
                </div>

            </lightning-card>

            <!-- Remove Applicant Button -->
            <lightning-button variant="destructive" label="Remove Applicant" data-index={index} onclick={removeApplicant} class="slds-m-top_small"></lightning-button>
        </div>
    </template>

    <!-- Add Applicant Button -->
    <lightning-button label="Add Applicant" onclick={addApplicant} class="slds-m-top_medium"></lightning-button>
</template>



<!--
  @description       : 
  @author            : 
  @group             : 
  @last modified on  : 08-09-2025
  @last modified by  : Pratik
-->
<template>
     <template for:each={applicants} for:item="applicant" for:index="index">
         <div key={applicant.key} class="slds-box slds-m-around_medium">
    <lightning-card title="Borrowers / Guarantors">

        <!-- Account Search Input -->
        <div class="slds-m-around_medium">
            <lightning-input 
                label="Select Existing Business Relationship Record"
                type="text"
                value={searchKey}
                onchange={handleSearchKeyChange}
                placeholder="Type account name..."
                class="slds-size_1-of-1">
            </lightning-input>

            <!-- Search Results Dropdown -->
            <template if:true={searchResults.length}>
                <div class="slds-box slds-m-top_x-small">
                    <template for:each={searchResults} for:item="acc">
                        <div key={acc.Id} class="slds-p-around_x-small slds-border_bottom" 
                             onclick={handleAccountSelect} data-id={acc.Id}>
                            {acc.Name}
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Form Fields -->
        <div class="slds-grid slds-wrap slds-m-around_medium">

            <lightning-input class="slds-size_1-of-2"
                label="Company Name"
                value={formData.companyName}
                data-field="companyName"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="DBA"
                value={formData.dba}
                data-field="dba"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Industry"
                value={formData.industry}
                data-field="industry"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Employees"
                value={formData.employees}
                type="number"
                data-field="employees"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Annual Revenue"
                value={formData.annualRevenue}
                data-field="annualRevenue"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Net Profit"
                value={formData.netProfit}
                data-field="netProfit"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Legal Entity"
                value={formData.legalEntity}
                data-field="legalEntity"
                onchange={handleInputChange}>
            </lightning-input>

            <!-- <lightning-input class="slds-size_1-of-2"
                type="date"
                label="Company Start Date"
                value={formData.startDate}
                data-field="startDate"
                onchange={handleInputChange}>
            </lightning-input> -->

            <!-- <lightning-input class="slds-size_1-of-1"
                label="Company Address"
                value={formData.address}
                data-field="address"
                onchange={handleInputChange}>
            </lightning-input> -->

            <lightning-textarea class="slds-size_1-of-1"
                label="Comment"
                value={formData.comment}
                data-field="comment"
                onchange={handleInputChange}>
            </lightning-textarea>
        </div>

      

    </lightning-card>
     <!-- Remove Applicant Button -->
            <lightning-button
                variant="destructive"
                label="Remove Applicant"
                data-index={index}
                onclick={removeApplicant}
                class="slds-m-top_small"
            >
            </lightning-button>
        </div>
        
     </template>

    
    

    <!-- Add Applicant Button -->
    <lightning-button label="Add Applicant" onclick={addApplicant} class="slds-m-top_medium"></lightning-button>
</template>



import { LightningElement, wire, track, api  } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import updateAccount from '@salesforce/apex/PartyDetailsController.updateAccount';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
    @api recordId; // Salesforce passes current ApplicationForm__c Id
      @track applicants = [];
    @api additionalApplicants = [];
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};
    @track selectedAccountId;

     // Helper to create an empty applicant object
    createEmptyApplicant() {
        return {
            key: Date.now(), // unique ID
            Id: '',
            selectedPartyProfile: '',
            firstName: '',
            middleName: '',
            lastName: '',
            email: '',
            phoneNumber: '',
            ssn: '',
            dob: '',
            Suffix: '',
            citizenship: ''
        };
    }


    connectedCallback() {
    if (this.recordId) {
        this.prefillAccountFromAppForm(this.recordId);
    }

    if (!this.additionalApplicants || this.additionalApplicants.length === 0) {
        this.addApplicant();
    } else {
        this.processAdditionalApplicant(this.additionalApplicants);
    }
}

async prefillAccountFromAppForm(appFormId) {
    try {
        const accountDetails = await getAccountDetailsFromAppForm({ appFormId });
        this.formData = { ...accountDetails };
        this.selectedAccountId = accountDetails.id; // optional
    } catch (error) {
        console.error('Error fetching related account:', error);
    }
}

    processAdditionalApplicant(applicants) {
        if (!Array.isArray(applicants)) {
            applicants = [applicants];
        }
        this.applicants = applicants.map((applicant) => {
            return {
                key: Date.now(),
                ...applicant
            };
        });
    }

    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        this.selectedAccountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            let details = await getAccountDetails({ accountId: this.selectedAccountId });
            this.formData = { ...details };
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }

    handleInputChange(event) {
        const field = event.target.dataset.field;
        this.formData[field] = event.target.value;
    }

    async handleUpdate() {
    try {
        await updateAccount({ accountId: this.formData.id, accDetails: this.formData });
        this.dispatchEvent(new ShowToastEvent({
            title: 'Success',
            message: 'Account updated successfully',
            variant: 'success'
        }));
    } catch (error) {
        console.error('Error updating account:', error);
        this.dispatchEvent(new ShowToastEvent({
            title: 'Error Updating Account',
            message: error.body ? error.body.message : 'Unknown error',
            variant: 'error'
        }));
    }
}

// Handle input changes for a specific applicant
    handleInputChange(event) {
        const index = event.target.dataset.index;
        const field = event.target.dataset.id;
        this.applicants[index][field] = event.target.value;
        this.updateToOmniScript();
    }

    // Add a new applicant (clone an empty applicant object)
    addApplicant() {
        this.applicants = [...this.applicants, this.createEmptyApplicant()];
        this.updateToOmniScript();
    }

    // Remove an applicant from the list
    removeApplicant(event) {
        const index = event.target.dataset.index;
        if (this.applicants.length > 1) {
            this.applicants.splice(index, 1);
            this.applicants = [...this.applicants]; // Re-trigger reactivity
        }
        this.updateToOmniScript();
    }

    // Method to handle the update in OmniScript
    // This method can be used to send data back to OmniScript if needed
    updateToOmniScript() {
        let data = { AdditionalApplicants: this.applicants };
        console.log('OUTPUT : ', JSON.stringify(data));
        this.omniApplyCallResp(data);
    }
}


public class PartyDetailsController {
	  @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + String.escapeSingleQuotes(searchKey) + '%';
        return [
            SELECT Id, Name
            FROM Account
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    // Note: this method does NOT query Billing or Start Date fields
    @AuraEnabled(cacheable=true)
    public static AccountDetails getAccountDetails(Id accountId) {
        if (accountId == null) {
            return new AccountDetails();
        }

        Account acc;
        try {
            acc = [
                SELECT Id, Name, nSBA__DBA__c, Industry, Legal_Entity__c, Role__c,
                       NumberOfEmployees, AnnualRevenue, Net_Profit__c, Comments__c
                FROM Account
                WHERE Id = :accountId
                LIMIT 1
            ];
        } catch (Exception e) {
            // Return a clear error message to LWC
            throw new AuraHandledException('Apex error in getAccountDetails: ' + e.getMessage());
        }

        AccountDetails details = new AccountDetails();
        details.companyName   = acc.Name;
        details.dba           = acc.get('nSBA__DBA__c') != null ? String.valueOf(acc.get('nSBA__DBA__c')) : null;
        details.industry      = acc.Industry;
        details.employees     = acc.NumberOfEmployees;
        details.annualRevenue = acc.AnnualRevenue != null ? String.valueOf(acc.AnnualRevenue) : null;
        details.netProfit     = acc.Net_Profit__c != null ? String.valueOf(acc.Net_Profit__c) : null;
        details.legalEntity   = acc.Legal_Entity__c;
        details.comment       = acc.Comments__c;
        return details;
    }

    public class AccountDetails {
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
        @AuraEnabled public String comment;
    }

	@AuraEnabled(cacheable=true)
public static AccountDetails getAccountDetailsFromAppForm(Id appFormId) {
    if(appFormId == null) return new AccountDetails();

    ApplicationForm app = [
        SELECT Id, AccountId 
        FROM ApplicationForm
        WHERE Id = :appFormId
        LIMIT 1
    ];

    if(app.AccountId == null){
        return new AccountDetails(); // no related account
    }

    return getAccountDetails(app.AccountId);
}
    
   @AuraEnabled
public static void updateAccount(Id accountId, AccountDetails accDetails) {
    try {
        Account acc = new Account(Id = accountId);

        acc.Name            = accDetails.companyName;
        acc.nSBA__DBA__c    = accDetails.dba;
        acc.Industry        = accDetails.industry;
        acc.NumberOfEmployees = accDetails.employees;

        if (!String.isBlank(accDetails.annualRevenue)) {
            acc.AnnualRevenue = Decimal.valueOf(accDetails.annualRevenue);
        }
        if (!String.isBlank(accDetails.netProfit)) {
            acc.Net_Profit__c = Decimal.valueOf(accDetails.netProfit);
        }

        acc.Legal_Entity__c = accDetails.legalEntity;
        acc.Comments__c     = accDetails.comment;

        // If you don't want to update address/startDate, skip them
        update acc;
    } catch (Exception e) {
        throw new AuraHandledException('Update failed: ' + e.getMessage());
    }
}


  /*  @AuraEnabled
    public static Id createApplicantFromAccount(AccountDetails accDetails) {
        Applicant app = new Applicant();
        app.Company_Name__c = accDetails.companyName;
        app.DBA__c = accDetails.dba;
        app.Industry__c = accDetails.industry;
        app.Employees__c = accDetails.employees != null ? Integer.valueOf(accDetails.employees) : null;
        app.Annual_Revenue__c = accDetails.annualRevenue != null ? Decimal.valueOf(accDetails.annualRevenue) : null;
        app.Net_Profit__c = accDetails.netProfit != null ? Decimal.valueOf(accDetails.netProfit) : null;
        app.Legal_Entity__c = accDetails.legalEntity;
       // app.Start_Date__c = accDetails.startDate;
        app.Comments__c = accDetails.comment;
        
        insert app;
        return app.Id;
    } */
}

@AuraEnabled(cacheable=true)
public static AccountDetails getAccountDetailsFromAppForm(Id appFormId) {
    if(appFormId == null) return new AccountDetails();

    ApplicationForm__c app = [
        SELECT Id, Account__c 
        FROM ApplicationForm__c 
        WHERE Id = :appFormId
        LIMIT 1
    ];

    if(app.Account__c == null){
        return new AccountDetails(); // no related account
    }

    return getAccountDetails(app.Account__c);
}


@api recordId; // Salesforce passes current ApplicationForm__c Id

connectedCallback() {
    if (this.recordId) {
        this.prefillAccountFromAppForm(this.recordId);
    }

    if (!this.additionalApplicants || this.additionalApplicants.length === 0) {
        this.addApplicant();
    } else {
        this.processAdditionalApplicant(this.additionalApplicants);
    }
}

async prefillAccountFromAppForm(appFormId) {
    try {
        const accountDetails = await getAccountDetailsFromAppForm({ appFormId });
        this.formData = { ...accountDetails };
        this.selectedAccountId = accountDetails.id; // optional
    } catch (error) {
        console.error('Error fetching related account:', error);
    }
}




import { LightningElement, wire, track, api  } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import updateAccount from '@salesforce/apex/PartyDetailsController.updateAccount';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
      @track applicants = [];
    @api additionalApplicants = [];
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};
    @track selectedAccountId;

     // Helper to create an empty applicant object
    createEmptyApplicant() {
        return {
            key: Date.now(), // unique ID
            Id: '',
            selectedPartyProfile: '',
            firstName: '',
            middleName: '',
            lastName: '',
            email: '',
            phoneNumber: '',
            ssn: '',
            dob: '',
            Suffix: '',
            citizenship: ''
        };
    }


    connectedCallback() {
        let applicants = this.additionalApplicants;

        // this.getDataFromAdditionalApplicants();
        if (!applicants) {
            this.addApplicant();
        } else {
            this.processAdditionalApplicant(applicants);
        }
    }
    processAdditionalApplicant(applicants) {
        if (!Array.isArray(applicants)) {
            applicants = [applicants];
        }
        this.applicants = applicants.map((applicant) => {
            return {
                key: Date.now(),
                ...applicant
            };
        });
    }

    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        this.selectedAccountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            let details = await getAccountDetails({ accountId: this.selectedAccountId });
            this.formData = { ...details };
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }

    handleInputChange(event) {
        const field = event.target.dataset.field;
        this.formData[field] = event.target.value;
    }

    async handleUpdate() {
    try {
        await updateAccount({ accountId: this.formData.id, accDetails: this.formData });
        this.dispatchEvent(new ShowToastEvent({
            title: 'Success',
            message: 'Account updated successfully',
            variant: 'success'
        }));
    } catch (error) {
        console.error('Error updating account:', error);
        this.dispatchEvent(new ShowToastEvent({
            title: 'Error Updating Account',
            message: error.body ? error.body.message : 'Unknown error',
            variant: 'error'
        }));
    }
}

// Handle input changes for a specific applicant
    handleInputChange(event) {
        const index = event.target.dataset.index;
        const field = event.target.dataset.id;
        this.applicants[index][field] = event.target.value;
        this.updateToOmniScript();
    }

    // Add a new applicant (clone an empty applicant object)
    addApplicant() {
        this.applicants = [...this.applicants, this.createEmptyApplicant()];
        this.updateToOmniScript();
    }

    // Remove an applicant from the list
    removeApplicant(event) {
        const index = event.target.dataset.index;
        if (this.applicants.length > 1) {
            this.applicants.splice(index, 1);
            this.applicants = [...this.applicants]; // Re-trigger reactivity
        }
        this.updateToOmniScript();
    }

    // Method to handle the update in OmniScript
    // This method can be used to send data back to OmniScript if needed
    updateToOmniScript() {
        let data = { AdditionalApplicants: this.applicants };
        console.log('OUTPUT : ', JSON.stringify(data));
        this.omniApplyCallResp(data);
    }
}

public class PartyDetailsController {
	  @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + String.escapeSingleQuotes(searchKey) + '%';
        return [
            SELECT Id, Name
            FROM Account
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    // Note: this method does NOT query Billing or Start Date fields
    @AuraEnabled(cacheable=true)
    public static AccountDetails getAccountDetails(Id accountId) {
        if (accountId == null) {
            return new AccountDetails();
        }

        Account acc;
        try {
            acc = [
                SELECT Id, Name, nSBA__DBA__c, Industry, Legal_Entity__c, Role__c,
                       NumberOfEmployees, AnnualRevenue, Net_Profit__c, Comments__c
                FROM Account
                WHERE Id = :accountId
                LIMIT 1
            ];
        } catch (Exception e) {
            // Return a clear error message to LWC
            throw new AuraHandledException('Apex error in getAccountDetails: ' + e.getMessage());
        }

        AccountDetails details = new AccountDetails();
        details.companyName   = acc.Name;
        details.dba           = acc.get('nSBA__DBA__c') != null ? String.valueOf(acc.get('nSBA__DBA__c')) : null;
        details.industry      = acc.Industry;
        details.employees     = acc.NumberOfEmployees;
        details.annualRevenue = acc.AnnualRevenue != null ? String.valueOf(acc.AnnualRevenue) : null;
        details.netProfit     = acc.Net_Profit__c != null ? String.valueOf(acc.Net_Profit__c) : null;
        details.legalEntity   = acc.Legal_Entity__c;
        details.comment       = acc.Comments__c;
        return details;
    }

    public class AccountDetails {
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
        @AuraEnabled public String comment;
    }

async handleUpdate() {
    try {
        await updateAccount({ accountId: this.formData.id, accDetails: this.formData });
        this.dispatchEvent(new ShowToastEvent({
            title: 'Success',
            message: 'Account updated successfully',
            variant: 'success'
        }));
    } catch (error) {
        console.error('Error updating account:', error);
        this.dispatchEvent(new ShowToastEvent({
            title: 'Error Updating Account',
            message: error.body ? error.body.message : 'Unknown error',
            variant: 'error'
        }));
    }
}



@AuraEnabled
public static void updateAccount(Id accountId, AccountDetails accDetails) {
    try {
        Account acc = new Account(Id = accountId);

        acc.Name            = accDetails.companyName;
        acc.nSBA__DBA__c    = accDetails.dba;
        acc.Industry        = accDetails.industry;
        acc.NumberOfEmployees = accDetails.employees;

        if (!String.isBlank(accDetails.annualRevenue)) {
            acc.AnnualRevenue = Decimal.valueOf(accDetails.annualRevenue);
        }
        if (!String.isBlank(accDetails.netProfit)) {
            acc.Net_Profit__c = Decimal.valueOf(accDetails.netProfit);
        }

        acc.Legal_Entity__c = accDetails.legalEntity;
        acc.Comments__c     = accDetails.comment;

        // If you don't want to update address/startDate, skip them
        update acc;
    } catch (Exception e) {
        throw new AuraHandledException('Update failed: ' + e.getMessage());
    }
}


<template>
    <lightning-card title="Borrowers / Guarantors">

        <!-- Account Search Input -->
        <div class="slds-m-around_medium">
            <lightning-input 
                label="Select Existing Business Relationship Record"
                type="text"
                value={searchKey}
                onchange={handleSearchKeyChange}
                placeholder="Type account name..."
                class="slds-size_1-of-1">
            </lightning-input>

            <!-- Search Results Dropdown -->
            <template if:true={searchResults.length}>
                <div class="slds-box slds-m-top_x-small">
                    <template for:each={searchResults} for:item="acc">
                        <div key={acc.Id} class="slds-p-around_x-small slds-border_bottom" 
                             onclick={handleAccountSelect} data-id={acc.Id}>
                            {acc.Name}
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Form Fields -->
        <div class="slds-grid slds-wrap slds-m-around_medium">

            <lightning-input class="slds-size_1-of-2"
                label="Company Name"
                value={formData.companyName}
                data-field="companyName"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="DBA"
                value={formData.dba}
                data-field="dba"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Industry"
                value={formData.industry}
                data-field="industry"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Employees"
                value={formData.employees}
                type="number"
                data-field="employees"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Annual Revenue"
                value={formData.annualRevenue}
                data-field="annualRevenue"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Net Profit"
                value={formData.netProfit}
                data-field="netProfit"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Legal Entity"
                value={formData.legalEntity}
                data-field="legalEntity"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                type="date"
                label="Company Start Date"
                value={formData.startDate}
                data-field="startDate"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-input class="slds-size_1-of-1"
                label="Company Address"
                value={formData.address}
                data-field="address"
                onchange={handleInputChange}>
            </lightning-input>

            <lightning-textarea class="slds-size_1-of-1"
                label="Comment"
                value={formData.comment}
                data-field="comment"
                onchange={handleInputChange}>
            </lightning-textarea>
        </div>

        <!-- Save Button -->
        <div class="slds-m-around_medium">
            <lightning-button label="Update Account" variant="brand" onclick={handleUpdate}></lightning-button>
        </div>

    </lightning-card>
</template>


import { LightningElement, track } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import updateAccount from '@salesforce/apex/PartyDetailsController.updateAccount';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};
    @track selectedAccountId;

    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        this.selectedAccountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            let details = await getAccountDetails({ accountId: this.selectedAccountId });
            this.formData = { ...details };
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }

    handleInputChange(event) {
        const field = event.target.dataset.field;
        this.formData[field] = event.target.value;
    }

    async handleUpdate() {
        try {
            await updateAccount({ accountId: this.selectedAccountId, accDetails: this.formData });
            this.dispatchEvent(new ShowToastEvent({
                title: 'Success',
                message: 'Account updated successfully',
                variant: 'success'
            }));
        } catch (error) {
            console.error('Error updating account:', error);
            this.dispatchEvent(new ShowToastEvent({
                title: 'Error',
                message: 'Failed to update account',
                variant: 'error'
            }));
        }
    }
}


@AuraEnabled
public static void updateAccount(Id accountId, AccountDetails accDetails) {
    Account acc = new Account(
        Id = accountId,
        Name = accDetails.companyName,
        nSBA__DBA__c = accDetails.dba,
        Industry = accDetails.industry,
        NumberOfEmployees = accDetails.employees,
        AnnualRevenue = Decimal.valueOf(accDetails.annualRevenue),
        Net_Profit__c = Decimal.valueOf(accDetails.netProfit),
        Legal_Entity__c = accDetails.legalEntity,
        Comments__c = accDetails.comment
    );
    update acc;
}


public with sharing class PartyDetailsController {

    @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + String.escapeSingleQuotes(searchKey) + '%';
        return [
            SELECT Id, Name
            FROM Account
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    // Note: this method does NOT query Billing or Start Date fields
    @AuraEnabled(cacheable=true)
    public static AccountDetails getAccountDetails(Id accountId) {
        if (accountId == null) {
            return new AccountDetails();
        }

        Account acc;
        try {
            acc = [
                SELECT Id, Name, nSBA__DBA__c, Industry, Legal_Entity__c, Role__c,
                       NumberOfEmployees, AnnualRevenue, Net_Profit__c, Comments__c
                FROM Account
                WHERE Id = :accountId
                LIMIT 1
            ];
        } catch (Exception e) {
            // Return a clear error message to LWC
            throw new AuraHandledException('Apex error in getAccountDetails: ' + e.getMessage());
        }

        AccountDetails details = new AccountDetails();
        details.companyName   = acc.Name;
        details.dba           = acc.get('nSBA__DBA__c') != null ? String.valueOf(acc.get('nSBA__DBA__c')) : null;
        details.industry      = acc.Industry;
        details.employees     = acc.NumberOfEmployees;
        details.annualRevenue = acc.AnnualRevenue != null ? String.valueOf(acc.AnnualRevenue) : null;
        details.netProfit     = acc.Net_Profit__c != null ? String.valueOf(acc.Net_Profit__c) : null;
        details.legalEntity   = acc.Legal_Entity__c;
        details.comment       = acc.Comments__c;
        return details;
    }

    public class AccountDetails {
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
        @AuraEnabled public String comment;
    }
}



import { LightningElement, track } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};

    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey && this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            const msg = (error && error.body && error.body.message) ? error.body.message : JSON.stringify(error);
            console.error('Error searching accounts:', msg);
            this.dispatchEvent(new ShowToastEvent({ title: 'Search error', message: msg, variant: 'error' }));
        }
    }

    async handleAccountSelect(event) {
        const accountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            const details = await getAccountDetails({ accountId });
            this.formData = details || {};
        } catch (error) {
            const msg = (error && error.body && error.body.message) ? error.body.message : JSON.stringify(error);
            console.error('Error fetching account details:', msg);
            this.dispatchEvent(new ShowToastEvent({ title: 'Fetch error', message: msg, variant: 'error' }));
        }
    }
}


import { LightningElement, wire, track, api } from 'lwc';
import searchAccounts from '@salesforce/apex/PartyDetailsController.searchAccounts';
import getAccountDetails from '@salesforce/apex/PartyDetailsController.getAccountDetails';
import { OmniscriptBaseMixin } from 'omnistudio/omniscriptBaseMixin';

export default class PartyDetails extends OmniscriptBaseMixin(LightningElement) {
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};

    // When user types in input
    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        let accountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            let details = await getAccountDetails({ accountId });
            this.formData = details;
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }
  
}


public class PartyDetailsController {
	 @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + searchKey + '%';
        return [
            SELECT Id, Name 
            FROM Account 
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    @AuraEnabled(cacheable=true)
    public static PartyDetailsController.AccountDetails getAccountDetails(Id accountId) {
        Account acc = [
            SELECT Id, Name, nSBA__DBA__c, Industry,Legal_Entity__c , Role__c, NumberOfEmployees, AnnualRevenue, 
                   Net_Profit__c,  BillingAddress, Comments__c
            FROM Account
            WHERE Id = :accountId
            LIMIT 1
        ];

        AccountDetails details = new AccountDetails();
        details.companyName   = acc.Name;
        details.dba           = acc.nSBA__DBA__c;
        details.industry      = acc.Industry;
        details.employees     = acc.NumberOfEmployees;
        details.annualRevenue = String.valueOf(acc.AnnualRevenue);
        details.netProfit     = String.valueOf(acc.Net_Profit__c);
        details.legalEntity   = acc.Legal_Entity__c;
       // details.startDate     = acc.Start_Date__c;
        details.address       = acc.BillingStreet + ', ' + acc.BillingCity + ', ' + acc.BillingState;
        details.comment       = acc.Comments__c;
        return details;
    }

    public class AccountDetails {
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
      //  @AuraEnabled public Date startDate;
        @AuraEnabled public String address;
        @AuraEnabled public String comment;
    } 



public with sharing class AccountController {
    
  public with sharing class AccountController {

    @AuraEnabled(cacheable=true)
    public static List<Account> searchAccounts(String searchKey) {
        String key = '%' + searchKey + '%';
        return [
            SELECT Id, Name 
            FROM Account 
            WHERE Name LIKE :key
            LIMIT 10
        ];
    }

    @AuraEnabled(cacheable=true)
    public static AccountDetails getAccountDetails(Id accountId) {
        Account acc = [
            SELECT Id, Name, DBA__c, Industry, NumberOfEmployees, AnnualRevenue,
                   Net_Profit__c, Legal_Entity__c, Start_Date__c,
                   BillingStreet, BillingCity, BillingState, BillingPostalCode, BillingCountry,
                   Comment__c
            FROM Account
            WHERE Id = :accountId
            LIMIT 1
        ];

        AccountDetails details = new AccountDetails();
        details.companyName   = acc.Name;
        details.dba           = acc.DBA__c;
        details.industry      = acc.Industry;
        details.employees     = acc.NumberOfEmployees;
        details.annualRevenue = String.valueOf(acc.AnnualRevenue);
        details.netProfit     = String.valueOf(acc.Net_Profit__c);
        details.legalEntity   = acc.Legal_Entity__c;
        details.startDate     = acc.Start_Date__c;
        details.address       = acc.BillingStreet + ', ' + acc.BillingCity + ', ' + acc.BillingState;
        details.comment       = acc.Comment__c;
        return details;
    }

    public class AccountDetails {
        @AuraEnabled public String companyName;
        @AuraEnabled public String dba;
        @AuraEnabled public String industry;
        @AuraEnabled public Integer employees;
        @AuraEnabled public String annualRevenue;
        @AuraEnabled public String netProfit;
        @AuraEnabled public String legalEntity;
        @AuraEnabled public Date startDate;
        @AuraEnabled public String address;
        @AuraEnabled public String comment;
    }
}

    @AuraEnabled
    public static Id createApplicantFromAccount(AccountDetails accDetails) {
        Applicant__c app = new Applicant__c();
        app.Company_Name__c = accDetails.companyName;
        app.DBA__c = accDetails.dba;
        app.Industry__c = accDetails.industry;
        app.Employees__c = accDetails.employees != null ? Integer.valueOf(accDetails.employees) : null;
        app.Annual_Revenue__c = accDetails.annualRevenue != null ? Decimal.valueOf(accDetails.annualRevenue) : null;
        app.Net_Profit__c = accDetails.netProfit != null ? Decimal.valueOf(accDetails.netProfit) : null;
        app.Legal_Entity__c = accDetails.legalEntity;
        app.Start_Date__c = accDetails.startDate;
        app.Comment__c = accDetails.comment;
        
        insert app;
        return app.Id;
    }
}

<template>
    <lightning-card title="Borrowers / Guarantors">

        <!-- Account Search Input -->
        <div class="slds-m-around_medium">
            <lightning-input 
                label="Select Existing Business Relationship Record"
                type="text"
                value={searchKey}
                onchange={handleSearchKeyChange}
                placeholder="Type account name..."
                class="slds-size_1-of-1">
            </lightning-input>

            <!-- Search Results Dropdown -->
            <template if:true={searchResults.length}>
                <div class="slds-box slds-m-top_x-small">
                    <template for:each={searchResults} for:item="acc">
                        <div key={acc.Id} class="slds-p-around_x-small slds-border_bottom" 
                             onclick={handleAccountSelect} data-id={acc.Id}>
                            {acc.Name}
                        </div>
                    </template>
                </div>
            </template>
        </div>

        <!-- Form Fields -->
        <div class="slds-grid slds-wrap slds-m-around_medium">

            <lightning-input class="slds-size_1-of-2"
                label="Company Name"
                value={formData.companyName}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="DBA"
                value={formData.dba}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Industry"
                value={formData.industry}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Employees"
                value={formData.employees}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Annual Revenue"
                value={formData.annualRevenue}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Net Profit"
                value={formData.netProfit}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Legal Entity"
                value={formData.legalEntity}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                type="date"
                label="Company Start Date"
                value={formData.startDate}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-1"
                label="Company Address"
                value={formData.address}
                disabled>
            </lightning-input>

            <lightning-textarea class="slds-size_1-of-1"
                label="Comment"
                value={formData.comment}
                disabled>
            </lightning-textarea>
        </div>

    </lightning-card>
</template>
import { LightningElement, track } from 'lwc';
import searchAccounts from '@salesforce/apex/AccountController.searchAccounts';
import getAccountDetails from '@salesforce/apex/AccountController.getAccountDetails';

export default class AccountApplicantForm extends LightningElement {
    @track searchKey = '';
    @track searchResults = [];
    @track formData = {};

    // When user types in input
    handleSearchKeyChange(event) {
        this.searchKey = event.target.value;
        if (this.searchKey.length > 1) {
            this.findAccounts();
        } else {
            this.searchResults = [];
        }
    }

    async findAccounts() {
        try {
            let results = await searchAccounts({ searchKey: this.searchKey });
            this.searchResults = results;
        } catch (error) {
            console.error('Error searching accounts:', error);
        }
    }

    async handleAccountSelect(event) {
        let accountId = event.currentTarget.dataset.id;
        this.searchResults = []; // close dropdown
        try {
            let details = await getAccountDetails({ accountId });
            this.formData = details;
        } catch (error) {
            console.error('Error fetching account details:', error);
        }
    }
}


<!-- Account Lookup -->
<template>
    <lightning-card title="Borrowers / Guarantors">

        <!-- Account Lookup -->
        <div class="slds-m-around_medium">
            <lightning-combobox
                name="accountLookup"
                label="Select Existing Business Relationship Record"
                value={selectedAccount}
                options={accountOptions}
                onchange={handleAccountChange}
                placeholder="Search Accounts..."
                class="slds-size_1-of-1">
            </lightning-combobox>
        </div>

        <!-- Form Fields -->
        <div class="slds-grid slds-wrap slds-m-around_medium">

            <lightning-input class="slds-size_1-of-2"
                label="Company Name"
                value={formData.companyName}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="DBA"
                value={formData.dba}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Industry"
                value={formData.industry}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Employees"
                value={formData.employees}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Annual Revenue"
                value={formData.annualRevenue}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Net Profit"
                value={formData.netProfit}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                label="Legal Entity"
                value={formData.legalEntity}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-2"
                type="date"
                label="Company Start Date"
                value={formData.startDate}
                disabled>
            </lightning-input>

            <lightning-input class="slds-size_1-of-1"
                label="Company Address"
                value={formData.address}
                disabled>
            </lightning-input>

            <lightning-textarea class="slds-size_1-of-1"
                label="Comment"
                value={formData.comment}
                disabled>
            </lightning-textarea>
        </div>

    </lightning-card>
</template>


import { LightningElement, track, wire } from 'lwc';
import getAccounts from '@salesforce/apex/AccountController.getAccounts';
import getAccountDetails from '@salesforce/apex/AccountController.getAccountDetails';

export default class AccountApplicantForm extends LightningElement {
    @track accountOptions = [];
    @track formData = {};
    selectedAccount;

    // Load Accounts for lookup
    @wire(getAccounts)
    wiredAccounts({ data, error }) {
        if (data) {
            this.accountOptions = data.map(acc => ({
                label: acc.Name,
                value: acc.Id
            }));
        } else if (error) {
            console.error('Error fetching accounts: ', error);
        }
    }

    // Handle account selection
    handleAccountChange(event) {
        this.selectedAccount = event.detail.value;
        this.fetchAccountDetails(this.selectedAccount);
    }

    // Fetch details for selected account
    async fetchAccountDetails(accountId) {
        try {
            let result = await getAccountDetails({ accountId });
            this.formData = result;
        } catch (error) {
            console.error('Error fetching account details: ', error);
        }
    }
}




